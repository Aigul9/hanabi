{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport assert from \"assert\";\nimport { cloneDeep, findIndex, flatMap, last, range, zipObject } from \"lodash\";\nimport { shuffle } from \"shuffle-seed\";\nimport { IColor, IGameStatus } from \"./state\";\nexport const colors = [IColor.WHITE, IColor.BLUE, IColor.RED, IColor.GREEN, IColor.YELLOW, IColor.MULTICOLOR];\nexport const numbers = [1, 2, 3, 4, 5];\nconst startingHandSize = {\n  2: 5,\n  3: 5,\n  4: 4,\n  5: 4\n};\nexport const MaxHints = 8;\nexport function isPlayable(card, playedCards) {\n  const isPreviousHere = card.number === 1 || // first card on the pile\n  findIndex(playedCards, c => card.number === c.number + 1 && card.color === c.color) > -1; // previous card belongs to the playedCards\n\n  const isSameNotHere = findIndex(playedCards, c => c.number === card.number && c.color === card.color) === -1;\n  return isPreviousHere && isSameNotHere;\n}\n/**\n * Side effect function that applies the given hint on a given hand's cards\n */\n\nfunction applyHint(hand, hint) {\n  hand.forEach(card => {\n    if (card[hint.type] === hint.value) {\n      // positive hint, e.g. card is a red 5 and the hint is \"color red\"\n      Object.keys(card.hint[hint.type]).forEach(value => {\n        if (value == hint.value) {\n          // == because we want '2' == 2\n          // it has to be this value\n          card.hint[hint.type][value] = 2;\n        } else {\n          // all other values are impossible\n          card.hint[hint.type][value] = 0;\n        }\n      });\n    } else {\n      // negative hint\n      card.hint[hint.type][hint.value] = 0;\n    }\n  });\n}\n\nexport function emptyHint(options) {\n  return {\n    color: {\n      blue: 1,\n      red: 1,\n      green: 1,\n      white: 1,\n      yellow: 1,\n      multicolor: options.multicolor ? 1 : 0\n    },\n    number: {\n      0: 0,\n      1: 1,\n      2: 1,\n      3: 1,\n      4: 1,\n      5: 1\n    }\n  };\n}\nexport function isReplayMode(state) {\n  return state.replayCursor !== undefined;\n}\nexport function isGameOver(state) {\n  return state.actionsLeft <= 0 || state.tokens.strikes >= 3 || getMaximumPossibleScore(state) === (state.playedCards || []).length;\n}\nexport function commitAction(state, action) {\n  // the function should be pure\n  const s = cloneDeep(state);\n  s.history.push(_objectSpread({}, state, {\n    turnsHistory: [],\n    history: []\n  }));\n  assert(action.from === state.currentPlayer);\n  const player = s.players[action.from];\n  let newCard = null;\n\n  if (action.action === \"discard\" || action.action === \"play\") {\n    // remove the card from hand\n    const [card] = player.hand.splice(action.cardIndex, 1);\n    action.card = card;\n    /** PLAY */\n\n    if (action.action === \"play\") {\n      if (isPlayable(card, s.playedCards)) {\n        s.playedCards.push(card);\n\n        if (card.number === 5) {\n          // play a 5, win a hint\n          if (s.tokens.hints < MaxHints) s.tokens.hints += 1;\n        }\n      } else {\n        // strike !\n        s.tokens.strikes += 1;\n        s.discardPile.push(card);\n      }\n    } else {\n      /** DISCARD */\n      if (s.tokens.hints < MaxHints) {\n        s.discardPile.push(card);\n        s.tokens.hints += 1;\n      } else {\n        throw new Error(\"Invalid action, cannot discard when the hints are maxed out!\");\n      }\n    } // in both cases (play, discard) we need to remove a card from the hand and get a new one\n\n\n    if (s.drawPile && s.drawPile.length) {\n      newCard = s.drawPile.pop();\n      newCard.hint = emptyHint(state.options);\n      player.hand.unshift(newCard);\n    }\n  }\n  /** HINT */\n\n\n  if (action.action === \"hint\") {\n    assert(s.tokens.hints > 0);\n    s.tokens.hints -= 1;\n    assert(action.from !== action.to);\n    const hand = s.players[action.to].hand;\n    applyHint(hand, action);\n  } // there's no card in the pile (or the last card was just drawn)\n  // decrease the actionsLeft counter.\n  // The game ends when it reaches 0.\n\n\n  if (!s.drawPile || s.drawPile.length === 0) {\n    s.actionsLeft -= 1;\n  } // update player\n\n\n  s.currentPlayer = (s.currentPlayer + 1) % s.options.playersCount; // update history\n\n  s.turnsHistory.push({\n    action,\n    card: newCard\n  });\n\n  if (isGameOver(s)) {\n    s.status = IGameStatus.OVER;\n  }\n\n  return s;\n}\n/**\n * Rollback the state for the given amount of turns\n */\n\nexport function goBackToState(state, turnsBack = 1) {\n  const lastState = last(state.history);\n\n  if (!lastState) {\n    return null;\n  }\n\n  const previousState = _objectSpread({\n    history: state.history.slice(0, -1),\n    turnsHistory: state.turnsHistory.slice(0, -1)\n  }, lastState);\n\n  if (--turnsBack === 0) {\n    return previousState;\n  }\n\n  return goBackToState(previousState, turnsBack);\n}\nexport function emptyPlayer(id, name) {\n  return {\n    hand: [],\n    name,\n    id,\n    bot: false\n  };\n}\nexport function getColors(state) {\n  return state.options.multicolor ? colors : colors.slice(0, -1);\n}\nexport function getScore(state) {\n  return state.playedCards.length;\n}\nexport function getMaximumScore(state) {\n  return state.options.multicolor ? 30 : 25;\n}\nexport function getPlayedCardsPile(state) {\n  const colors = getColors(state);\n  return zipObject(colors, colors.map(color => {\n    const topCard = last(state.playedCards.filter(card => card.color === color));\n    return topCard ? topCard.number : 0;\n  }));\n}\n/**\n * Compute the max possible score with remaining cards in hand & deck\n * Doesn't take in account remaining turns\n */\n\nexport function getMaximumPossibleScore(state) {\n  const playableCards = [...state.drawPile, ...flatMap(state.players, p => p.hand)];\n  const playedCardsPile = getPlayedCardsPile(state);\n  let maxScore = getMaximumScore(state);\n  Object.keys(playedCardsPile).forEach(color => {\n    let value = playedCardsPile[color];\n\n    while (value < 5) {\n      const nextCard = playableCards.find(card => card.color === color && card.number === value + 1);\n\n      if (!nextCard) {\n        maxScore -= 5 - value;\n        break;\n      }\n\n      value += 1;\n    }\n  });\n  return maxScore;\n}\nexport function joinGame(state, player) {\n  const game = cloneDeep(state);\n  const hand = game.drawPile.splice(0, startingHandSize[game.options.playersCount]);\n  game.players = game.players || [];\n  game.players.push(_objectSpread({}, player, {\n    hand,\n    index: game.players.length\n  }));\n  hand.forEach(card => card.hint = emptyHint(state.options));\n  return game;\n}\nexport function newGame(options) {\n  assert(options.playersCount > 1 && options.playersCount < 6); // all cards but multicolors\n\n  let cards = flatMap(colors.slice(0, -1), color => [{\n    number: 1,\n    color\n  }, {\n    number: 1,\n    color\n  }, {\n    number: 1,\n    color\n  }, {\n    number: 2,\n    color\n  }, {\n    number: 2,\n    color\n  }, {\n    number: 3,\n    color\n  }, {\n    number: 3,\n    color\n  }, {\n    number: 4,\n    color\n  }, {\n    number: 4,\n    color\n  }, {\n    number: 5,\n    color\n  }]); // Add extensions cards when applicable\n\n  if (options.multicolor) {\n    cards.push({\n      number: 1,\n      color: IColor.MULTICOLOR\n    }, {\n      number: 2,\n      color: IColor.MULTICOLOR\n    }, {\n      number: 3,\n      color: IColor.MULTICOLOR\n    }, {\n      number: 4,\n      color: IColor.MULTICOLOR\n    }, {\n      number: 5,\n      color: IColor.MULTICOLOR\n    });\n  }\n\n  cards = cards.map((c, i) => _objectSpread({}, c, {\n    id: i\n  }));\n  const deck = shuffle(cards, options.seed);\n  const currentPlayer = shuffle(range(options.playersCount), options.seed)[0];\n  return {\n    id: options.id,\n    status: IGameStatus.LOBBY,\n    playedCards: [],\n    drawPile: deck,\n    discardPile: [],\n    players: [],\n    tokens: {\n      hints: MaxHints,\n      strikes: 0\n    },\n    currentPlayer,\n    options,\n    actionsLeft: options.playersCount + 1,\n    // this will be decreased when the draw pile is empty\n    turnsHistory: [],\n    history: [],\n    createdAt: Date.now(),\n    synced: false\n  };\n}","map":{"version":3,"sources":["/Users/sarahmamy/Workspace/hanabi/src/game/actions.ts"],"names":["assert","cloneDeep","findIndex","flatMap","last","range","zipObject","shuffle","IColor","IGameStatus","colors","WHITE","BLUE","RED","GREEN","YELLOW","MULTICOLOR","numbers","startingHandSize","MaxHints","isPlayable","card","playedCards","isPreviousHere","number","c","color","isSameNotHere","applyHint","hand","hint","forEach","type","value","Object","keys","emptyHint","options","blue","red","green","white","yellow","multicolor","isReplayMode","state","replayCursor","undefined","isGameOver","actionsLeft","tokens","strikes","getMaximumPossibleScore","length","commitAction","action","s","history","push","turnsHistory","from","currentPlayer","player","players","newCard","splice","cardIndex","hints","discardPile","Error","drawPile","pop","unshift","to","playersCount","status","OVER","goBackToState","turnsBack","lastState","previousState","slice","emptyPlayer","id","name","bot","getColors","getScore","getMaximumScore","getPlayedCardsPile","map","topCard","filter","playableCards","p","playedCardsPile","maxScore","nextCard","find","joinGame","game","index","newGame","cards","i","deck","seed","LOBBY","createdAt","Date","now","synced"],"mappings":"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","sourcesContent":["import assert from \"assert\";\nimport { cloneDeep, findIndex, flatMap, last, range, zipObject } from \"lodash\";\nimport { shuffle } from \"shuffle-seed\";\n\nimport IGameState, {\n  IAction,\n  ICard,\n  ICardHint,\n  IColor,\n  IGameOptions,\n  IGameStatus,\n  IHand,\n  IHintAction,\n  INumber,\n  IPlayer\n} from \"./state\";\n\nexport const colors: IColor[] = [\n  IColor.WHITE,\n  IColor.BLUE,\n  IColor.RED,\n  IColor.GREEN,\n  IColor.YELLOW,\n  IColor.MULTICOLOR\n];\n\nexport const numbers: INumber[] = [1, 2, 3, 4, 5];\n\nconst startingHandSize = { 2: 5, 3: 5, 4: 4, 5: 4 };\nexport const MaxHints = 8;\n\nexport function isPlayable(card: ICard, playedCards: ICard[]): boolean {\n  const isPreviousHere =\n    card.number === 1 || // first card on the pile\n    findIndex(\n      playedCards,\n      c => card.number === c.number + 1 && card.color === c.color\n    ) > -1; // previous card belongs to the playedCards\n\n  const isSameNotHere =\n    findIndex(\n      playedCards,\n      c => c.number === card.number && c.color === card.color\n    ) === -1;\n\n  return isPreviousHere && isSameNotHere;\n}\n\n/**\n * Side effect function that applies the given hint on a given hand's cards\n */\nfunction applyHint(hand: IHand, hint: IHintAction) {\n  hand.forEach(card => {\n    if (card[hint.type] === hint.value) {\n      // positive hint, e.g. card is a red 5 and the hint is \"color red\"\n      Object.keys(card.hint[hint.type]).forEach(value => {\n        if (value == hint.value) {\n          // == because we want '2' == 2\n          // it has to be this value\n          card.hint[hint.type][value] = 2;\n        } else {\n          // all other values are impossible\n          card.hint[hint.type][value] = 0;\n        }\n      });\n    } else {\n      // negative hint\n      card.hint[hint.type][hint.value] = 0;\n    }\n  });\n}\n\nexport function emptyHint(options: IGameOptions): ICardHint {\n  return {\n    color: {\n      blue: 1,\n      red: 1,\n      green: 1,\n      white: 1,\n      yellow: 1,\n      multicolor: options.multicolor ? 1 : 0\n    },\n    number: { 0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1 }\n  };\n}\n\nexport function isReplayMode(state: IGameState) {\n  return state.replayCursor !== undefined;\n}\n\nexport function isGameOver(state: IGameState) {\n  return (\n    state.actionsLeft <= 0 ||\n    state.tokens.strikes >= 3 ||\n    getMaximumPossibleScore(state) === (state.playedCards || []).length\n  );\n}\n\nexport function commitAction(state: IGameState, action: IAction): IGameState {\n  // the function should be pure\n  const s = cloneDeep(state) as IGameState;\n\n  s.history.push({ ...state, turnsHistory: [], history: [] });\n\n  assert(action.from === state.currentPlayer);\n  const player = s.players[action.from];\n\n  let newCard = null as ICard;\n  if (action.action === \"discard\" || action.action === \"play\") {\n    // remove the card from hand\n    const [card] = player.hand.splice(action.cardIndex, 1);\n    action.card = card;\n    /** PLAY */\n    if (action.action === \"play\") {\n      if (isPlayable(card, s.playedCards)) {\n        s.playedCards.push(card);\n        if (card.number === 5) {\n          // play a 5, win a hint\n          if (s.tokens.hints < MaxHints) s.tokens.hints += 1;\n        }\n      } else {\n        // strike !\n        s.tokens.strikes += 1;\n        s.discardPile.push(card);\n      }\n    } else {\n      /** DISCARD */\n      if (s.tokens.hints < MaxHints) {\n        s.discardPile.push(card);\n        s.tokens.hints += 1;\n      } else {\n        throw new Error(\n          \"Invalid action, cannot discard when the hints are maxed out!\"\n        );\n      }\n    }\n\n    // in both cases (play, discard) we need to remove a card from the hand and get a new one\n    if (s.drawPile && s.drawPile.length) {\n      newCard = s.drawPile.pop();\n      newCard.hint = emptyHint(state.options);\n      player.hand.unshift(newCard);\n    }\n  }\n\n  /** HINT */\n  if (action.action === \"hint\") {\n    assert(s.tokens.hints > 0);\n    s.tokens.hints -= 1;\n\n    assert(action.from !== action.to);\n    const hand = s.players[action.to].hand;\n    applyHint(hand, action);\n  }\n\n  // there's no card in the pile (or the last card was just drawn)\n  // decrease the actionsLeft counter.\n  // The game ends when it reaches 0.\n  if (!s.drawPile || s.drawPile.length === 0) {\n    s.actionsLeft -= 1;\n  }\n\n  // update player\n  s.currentPlayer = (s.currentPlayer + 1) % s.options.playersCount;\n\n  // update history\n  s.turnsHistory.push({ action, card: newCard });\n\n  if (isGameOver(s)) {\n    s.status = IGameStatus.OVER;\n  }\n\n  return s;\n}\n\n/**\n * Rollback the state for the given amount of turns\n */\nexport function goBackToState(state: IGameState, turnsBack = 1) {\n  const lastState = last(state.history);\n\n  if (!lastState) {\n    return null;\n  }\n\n  const previousState = {\n    history: state.history.slice(0, -1),\n    turnsHistory: state.turnsHistory.slice(0, -1),\n    ...lastState\n  };\n\n  if (--turnsBack === 0) {\n    return previousState;\n  }\n\n  return goBackToState(previousState, turnsBack);\n}\n\nexport function emptyPlayer(id: string, name: string): IPlayer {\n  return {\n    hand: [],\n    name,\n    id,\n    bot: false\n  };\n}\n\nexport function getColors(state: IGameState) {\n  return state.options.multicolor ? colors : colors.slice(0, -1);\n}\n\nexport function getScore(state: IGameState) {\n  return state.playedCards.length;\n}\n\nexport function getMaximumScore(state: IGameState) {\n  return state.options.multicolor ? 30 : 25;\n}\n\nexport function getPlayedCardsPile(\n  state: IGameState\n): { [key in IColor]: INumber } {\n  const colors = getColors(state);\n\n  return zipObject(\n    colors,\n    colors.map(color => {\n      const topCard = last(\n        state.playedCards.filter(card => card.color === color)\n      );\n\n      return topCard ? topCard.number : 0;\n    })\n  ) as { [key in IColor]: INumber };\n}\n\n/**\n * Compute the max possible score with remaining cards in hand & deck\n * Doesn't take in account remaining turns\n */\nexport function getMaximumPossibleScore(state: IGameState): number {\n  const playableCards = [\n    ...state.drawPile,\n    ...flatMap(state.players, p => p.hand)\n  ];\n  const playedCardsPile = getPlayedCardsPile(state);\n\n  let maxScore = getMaximumScore(state);\n\n  Object.keys(playedCardsPile).forEach(color => {\n    let value = playedCardsPile[color];\n\n    while (value < 5) {\n      const nextCard = playableCards.find(\n        card => card.color === color && card.number === value + 1\n      );\n\n      if (!nextCard) {\n        maxScore -= 5 - value;\n        break;\n      }\n      value += 1;\n    }\n  });\n\n  return maxScore;\n}\n\nexport function joinGame(state: IGameState, player: IPlayer): IGameState {\n  const game = cloneDeep(state) as IGameState;\n  const hand = game.drawPile.splice(\n    0,\n    startingHandSize[game.options.playersCount]\n  );\n\n  game.players = game.players || [];\n  game.players.push({ ...player, hand, index: game.players.length });\n\n  hand.forEach(card => (card.hint = emptyHint(state.options)));\n\n  return game;\n}\n\nexport function newGame(options: IGameOptions): IGameState {\n  assert(options.playersCount > 1 && options.playersCount < 6);\n\n  // all cards but multicolors\n  let cards = flatMap(colors.slice(0, -1), color => [\n    { number: 1, color },\n    { number: 1, color },\n    { number: 1, color },\n    { number: 2, color },\n    { number: 2, color },\n    { number: 3, color },\n    { number: 3, color },\n    { number: 4, color },\n    { number: 4, color },\n    { number: 5, color }\n  ]);\n\n  // Add extensions cards when applicable\n  if (options.multicolor) {\n    cards.push(\n      { number: 1, color: IColor.MULTICOLOR },\n      { number: 2, color: IColor.MULTICOLOR },\n      { number: 3, color: IColor.MULTICOLOR },\n      { number: 4, color: IColor.MULTICOLOR },\n      { number: 5, color: IColor.MULTICOLOR }\n    );\n  }\n\n  cards = cards.map((c, i) => ({ ...c, id: i })) as ICard[];\n\n  const deck = shuffle(cards, options.seed);\n\n  const currentPlayer = shuffle(range(options.playersCount), options.seed)[0];\n\n  return {\n    id: options.id,\n    status: IGameStatus.LOBBY,\n    playedCards: [],\n    drawPile: deck,\n    discardPile: [],\n    players: [],\n    tokens: {\n      hints: MaxHints,\n      strikes: 0\n    },\n    currentPlayer,\n    options,\n    actionsLeft: options.playersCount + 1, // this will be decreased when the draw pile is empty\n    turnsHistory: [],\n    history: [],\n    createdAt: Date.now(),\n    synced: false\n  };\n}\n"]},"metadata":{},"sourceType":"module"}