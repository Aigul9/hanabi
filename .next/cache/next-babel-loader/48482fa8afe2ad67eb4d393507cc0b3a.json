{"ast":null,"code":"import { defaults } from \"lodash\";\n/**\n * game state\n */\n\nexport let GameMode;\n\n(function (GameMode) {\n  GameMode[\"NETWORK\"] = \"network\";\n  GameMode[\"PASS_AND_PLAY\"] = \"pass_and_play\";\n})(GameMode || (GameMode = {}));\n\nexport let IGameHintsLevel;\n\n(function (IGameHintsLevel) {\n  IGameHintsLevel[\"ALL\"] = \"all\";\n  IGameHintsLevel[\"DIRECT\"] = \"direct\";\n  IGameHintsLevel[\"NONE\"] = \"none\";\n})(IGameHintsLevel || (IGameHintsLevel = {}));\n\nexport let IGameStatus;\n\n(function (IGameStatus) {\n  IGameStatus[\"LOBBY\"] = \"lobby\";\n  IGameStatus[\"ONGOING\"] = \"ongoing\";\n  IGameStatus[\"OVER\"] = \"over\";\n})(IGameStatus || (IGameStatus = {}));\n\nexport let IColor;\n\n(function (IColor) {\n  IColor[\"RED\"] = \"red\";\n  IColor[\"GREEN\"] = \"green\";\n  IColor[\"BLUE\"] = \"blue\";\n  IColor[\"WHITE\"] = \"white\";\n  IColor[\"YELLOW\"] = \"yellow\";\n  IColor[\"MULTICOLOR\"] = \"multicolor\";\n})(IColor || (IColor = {}));\n\nexport let IHintLevel; // an array of 2 (direct hint), 1 (still possible), or 0 (impossible)\n// e.g. a color hint onto an card turns all but one values to 0, and one value to 2.\n// a color hint onto a card give all the other cards in the hand a 0 for that color.\n// it's something public, i.e. information that has been given\n// to all players\n\n(function (IHintLevel) {\n  IHintLevel[IHintLevel[\"IMPOSSIBLE\"] = 0] = \"IMPOSSIBLE\";\n  IHintLevel[IHintLevel[\"POSSIBLE\"] = 1] = \"POSSIBLE\";\n  IHintLevel[IHintLevel[\"SURE\"] = 2] = \"SURE\";\n})(IHintLevel || (IHintLevel = {}));\n\n// empty arrays are returned as null in Firebase, so we fill\n// them back to avoid having to type check everywhere\nexport function fillEmptyValues(state) {\n  return defaults(state, {\n    playedCards: [],\n    drawPile: [],\n    discardPile: [],\n    players: (state.players || []).map(player => defaults(player, {\n      hand: []\n    })),\n    turnsHistory: [],\n    history: [],\n    reactions: []\n  });\n}","map":{"version":3,"sources":["/Users/sarahmamy/Workspace/hanabi/src/game/state.ts"],"names":["defaults","GameMode","IGameHintsLevel","IGameStatus","IColor","IHintLevel","fillEmptyValues","state","playedCards","drawPile","discardPile","players","map","player","hand","turnsHistory","history","reactions"],"mappings":"AAAA,SAASA,QAAT,QAAyB,QAAzB;AAEA;;;;AA4CA,WAAYC,QAAZ;;WAAYA,Q;AAAAA,EAAAA,Q;AAAAA,EAAAA,Q;GAAAA,Q,KAAAA,Q;;AAKZ,WAAYC,eAAZ;;WAAYA,e;AAAAA,EAAAA,e;AAAAA,EAAAA,e;AAAAA,EAAAA,e;GAAAA,e,KAAAA,e;;AASZ,WAAYC,WAAZ;;WAAYA,W;AAAAA,EAAAA,W;AAAAA,EAAAA,W;AAAAA,EAAAA,W;GAAAA,W,KAAAA,W;;AAMZ,WAAYC,MAAZ;;WAAYA,M;AAAAA,EAAAA,M;AAAAA,EAAAA,M;AAAAA,EAAAA,M;AAAAA,EAAAA,M;AAAAA,EAAAA,M;AAAAA,EAAAA,M;GAAAA,M,KAAAA,M;;AAWZ,WAAYC,UAAZ,C,CAMA;AACA;AACA;AACA;AACA;;WAVYA,U;AAAAA,EAAAA,U,CAAAA,U;AAAAA,EAAAA,U,CAAAA,U;AAAAA,EAAAA,U,CAAAA,U;GAAAA,U,KAAAA,U;;AA4EZ;AACA;AACA,OAAO,SAASC,eAAT,CAAyBC,KAAzB,EAAwD;AAC7D,SAAOP,QAAQ,CAACO,KAAD,EAAQ;AACrBC,IAAAA,WAAW,EAAE,EADQ;AAErBC,IAAAA,QAAQ,EAAE,EAFW;AAGrBC,IAAAA,WAAW,EAAE,EAHQ;AAIrBC,IAAAA,OAAO,EAAE,CAACJ,KAAK,CAACI,OAAN,IAAiB,EAAlB,EAAsBC,GAAtB,CAA0BC,MAAM,IACvCb,QAAQ,CAACa,MAAD,EAAS;AACfC,MAAAA,IAAI,EAAE;AADS,KAAT,CADD,CAJY;AASrBC,IAAAA,YAAY,EAAE,EATO;AAUrBC,IAAAA,OAAO,EAAE,EAVY;AAWrBC,IAAAA,SAAS,EAAE;AAXU,GAAR,CAAf;AAaD","sourcesContent":["import { defaults } from \"lodash\";\n\n/**\n * game state\n */\n\nexport default interface IGameState {\n  id: string;\n  status: IGameStatus;\n  playedCards: ICard[];\n  drawPile: ICard[];\n  discardPile: ICard[];\n  players: IPlayer[];\n  tokens: ITokens;\n  currentPlayer: number;\n  options: IGameOptions;\n  // this is initiated as the number of players + 1 and serves for\n  // the last round of game when the draw is empty\n  actionsLeft: number;\n  turnsHistory: ITurn[];\n  history: IGameState[];\n  createdAt: number;\n  synced: boolean;\n  // Replay mode\n  replayCursor?: number;\n  originalGame?: IGameState;\n}\n\n/**\n * Subtypes of the game state\n */\n\nexport interface IGameOptions {\n  id: string;\n  playersCount: number;\n  multicolor: boolean;\n  allowRollback: boolean;\n  preventLoss: boolean;\n  seed: string;\n  private: boolean;\n  hintsLevel: IGameHintsLevel;\n  turnsHistory: boolean;\n  botsWait: number;\n  gameMode: GameMode;\n}\n\nexport enum GameMode {\n  NETWORK = \"network\",\n  PASS_AND_PLAY = \"pass_and_play\"\n}\n\nexport enum IGameHintsLevel {\n  // Direct hints & game deductions are displayed (TBD)\n  ALL = \"all\",\n  // Direct hints are displayed\n  DIRECT = \"direct\",\n  // No hints displayd\n  NONE = \"none\"\n}\n\nexport enum IGameStatus {\n  LOBBY = \"lobby\",\n  ONGOING = \"ongoing\",\n  OVER = \"over\"\n}\n\nexport enum IColor {\n  RED = \"red\",\n  GREEN = \"green\",\n  BLUE = \"blue\",\n  WHITE = \"white\",\n  YELLOW = \"yellow\",\n  MULTICOLOR = \"multicolor\"\n}\n\nexport type INumber = 1 | 2 | 3 | 4 | 5;\n\nexport enum IHintLevel {\n  IMPOSSIBLE = 0,\n  POSSIBLE = 1,\n  SURE = 2\n}\n\n// an array of 2 (direct hint), 1 (still possible), or 0 (impossible)\n// e.g. a color hint onto an card turns all but one values to 0, and one value to 2.\n// a color hint onto a card give all the other cards in the hand a 0 for that color.\n// it's something public, i.e. information that has been given\n// to all players\nexport interface ICardHint {\n  color: { [key in IColor]: IHintLevel };\n  number: { [key in 0 | 1 | 2 | 3 | 4 | 5]: IHintLevel };\n}\n\nexport type IHand = ICard[];\n\nexport interface ICard {\n  color: IColor;\n  number: INumber;\n  hint?: ICardHint;\n  id?: number;\n}\n\nexport type IActionType = \"discard\" | \"play\" | \"hint\";\n\nexport interface IDiscardAction {\n  action: \"discard\";\n  from: number;\n  card?: ICard;\n  cardIndex: number;\n}\n\nexport interface IPlayAction {\n  action: \"play\";\n  from: number;\n  card?: ICard;\n  cardIndex: number;\n}\n\nexport type IHintType = \"color\" | \"number\";\n\nexport interface IHintAction {\n  action: \"hint\";\n  from: number;\n  to: number;\n  type: IHintType;\n  value: IColor | INumber;\n}\n\nexport type IAction = IDiscardAction | IPlayAction | IHintAction;\n\nexport interface ITurn {\n  action: IAction;\n  card?: ICard;\n}\n\nexport interface IPlayer {\n  id: string;\n  name: string;\n  hand?: IHand;\n  reaction?: string;\n  lastAction?: IAction;\n  index?: number;\n  notified?: boolean;\n  bot: boolean;\n}\n\n// the *remaining* strikes and hints.\n// There are 8 hints and 3 strikes to begin with.\nexport interface ITokens {\n  hints: number;\n  strikes: number;\n}\n\n// empty arrays are returned as null in Firebase, so we fill\n// them back to avoid having to type check everywhere\nexport function fillEmptyValues(state: IGameState): IGameState {\n  return defaults(state, {\n    playedCards: [],\n    drawPile: [],\n    discardPile: [],\n    players: (state.players || []).map(player =>\n      defaults(player, {\n        hand: []\n      })\n    ),\n    turnsHistory: [],\n    history: [],\n    reactions: []\n  });\n}\n"]},"metadata":{},"sourceType":"module"}