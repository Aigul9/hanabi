{"ast":null,"code":"import { cloneDeep, filter, findLastIndex } from \"lodash\";\nimport { colors, commitAction, getPlayedCardsPile, isPlayable, numbers } from \"./actions\";\nexport let IDeductionStatus;\n\n(function (IDeductionStatus) {\n  IDeductionStatus[IDeductionStatus[\"PLAYABLE\"] = 0] = \"PLAYABLE\";\n  IDeductionStatus[IDeductionStatus[\"HAPPYDISCARD\"] = 1] = \"HAPPYDISCARD\";\n  IDeductionStatus[IDeductionStatus[\"DISCARD\"] = 2] = \"DISCARD\";\n  IDeductionStatus[IDeductionStatus[\"SADDISCARD\"] = 3] = \"SADDISCARD\";\n})(IDeductionStatus || (IDeductionStatus = {}));\n\n/**\n * Check whether the current card can be in hand\n */\nfunction isCardPossible(card, possibleCards) {\n  return possibleCards.findIndex(c => c.number === card.number && c.color === card.color) > -1;\n}\n\nfunction isCardDangerous(card, state) {\n  if (!isCardEverPlayable(card, state)) {\n    return false;\n  }\n\n  if (card.color === \"multicolor\" || card.number === 5) {\n    return true;\n  }\n\n  if (state.discardPile.find(c => c.color === card.color && c.number === card.number)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isCardEverPlayable(card, state) {\n  const playedCardsPile = getPlayedCardsPile(state); // if the card has already been played once\n\n  if (playedCardsPile[card.color] >= card.number) {\n    return false;\n  } else if (playedCardsPile[card.color] < card.number - 1) {\n    // let's check whether the cards in between have been discarded\n    // e.g. the game pile is a 3 Red, the 2 4s in the discard, and I have a 5 Red\n    for (let i = playedCardsPile[card.color] + 1; i < card.number; i++) {\n      const discarded = filter(state.discardPile, e => e.color === card.color && e.number === i);\n      const cardCount = card.color === \"multicolor\" ? 1 : 2;\n\n      if (discarded.length === cardCount) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Check whether the current card can be discarded\n */\n\n\nfunction isCardDiscardable(card, state) {\n  // AI can discard a card that can never be played (already played or because of discards)\n  if (card.deductions.every(deduction => !isCardEverPlayable(deduction, state))) {\n    return true;\n  } // don't discard necessarily dangerous cards\n\n\n  if (card.deductions.every(deduction => isCardDangerous(deduction, state))) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function getHintDeductions(hint, possibleCards) {\n  const deductions = [];\n  colors.forEach(color => {\n    numbers.forEach(number => {\n      if (hint.color[color] > 0 && hint.number[number] > 0 && isCardPossible({\n        color,\n        number\n      }, possibleCards)) {\n        deductions.push({\n          number: number,\n          color,\n          deductionLevel: 0\n        });\n      }\n    });\n  });\n  return deductions;\n}\n\nfunction getPossibleCards(state, player) {\n  return [...state.drawPile, ...Object.values(state.players)[player].hand].map(c => ({\n    color: c.color,\n    number: c.number\n  }));\n}\n/**\n * A deduction is a possible value for a card, inferred from different deduction levels.\n * Level 0: all possible values (color, number) given the card's hints are of level 0 (or more)\n * Level 1: all possible values given the card's hints and all observable cards (other players games, discard pile) are of level 1 (or more)\n * Level 2: all level 1 values that are compatible with the previous player's action being optimal\n * Level 3: all level 2 values that are compatible with the the two previous actions being optimal\n * ...\n * A higher level deduction is less certain (although 0 and 1 are certain and deterministic)\n * but makes the card more likely to be played.\n *\n * Before playing, each deduction will be assigned a status (IDeductionStatus)\n * (playing a 5) > (playing a playable card) > (happy discard) > (giving a hint) > (discard) > (sad discard)\n *\n */\n\n\nexport function getLastOptimistCardOfCurrentPlayer(state) {\n  const lastTimeHinted = findLastIndex(state.turnsHistory, g => g.action.action === \"hint\" && g.action.to === state.currentPlayer);\n\n  if (lastTimeHinted === -1) {\n    return null;\n  }\n\n  const lastHintReceived = state.turnsHistory[lastTimeHinted].action;\n  const gameWhenLastHinted = state.history[lastTimeHinted].players[state.currentPlayer].hand;\n  const firstHintedCard = gameWhenLastHinted.find(card => card[lastHintReceived.type] === lastHintReceived.value);\n  return firstHintedCard || null;\n}\nexport function gameStateToGameView(gameState) {\n  // copy the state\n  const state = cloneDeep(gameState);\n  state.gameViews = [];\n  const lastOptimistCard = getLastOptimistCardOfCurrentPlayer(state); // add a parallel array to the players that give their view of the game\n  // and make all level 0 deductions\n\n  Object.values(state.players).forEach((player, i) => {\n    const gameView = {\n      hand: []\n    };\n    const possibleCards = getPossibleCards(state, i);\n    player.hand.forEach(card => {\n      gameView.hand.push({\n        hint: card.hint,\n        deductions: getHintDeductions(card.hint, possibleCards),\n        optimist: lastOptimistCard && card.id === lastOptimistCard.id\n      });\n    });\n    state.gameViews.push(gameView);\n  });\n  return state;\n}\nexport function commitViewAction(state, action) {\n  // change how players change their views given a certain action\n  const newState = commitAction(state, action);\n  newState.gameViews = state.gameViews;\n\n  if (action.action === \"hint\") {// @todo change the player view of the person who received a hint\n  } else {// @todo check what card was just drawn and apply new knowledge to other players\n    }\n\n  return newState;\n}\n\nfunction findGivableHint(hand, pIndex, state) {\n  // find the first playable card and give a hint on it.\n  // if possible, give an optimist hint.\n  for (let i = 0; i < hand.length; i++) {\n    const card = hand[i];\n\n    if (isPlayable(card, state.playedCards) && (card.hint.color[card.color] < 2 || card.hint.number[card.number] < 2)) {\n      // find the type of hint to give, trying to find the most optimist one\n      // (if there's a card with the same color, give the number hint)\n      let type;\n\n      if (hand.slice(0, i).find(c => c.color === card.color)) {\n        type = card.hint.number[card.number] < 2 ? \"number\" : \"color\";\n      } else {\n        type = card.hint.color[card.color] < 2 ? \"color\" : \"number\";\n      }\n\n      return {\n        action: \"hint\",\n        from: state.currentPlayer,\n        to: pIndex,\n        type,\n        value: card[type]\n      };\n    }\n  } // give a hint on the last card to avoid discard if possible\n\n\n  const lastCard = hand[hand.length - 1];\n\n  if (isCardDangerous(lastCard, state) && (lastCard.hint.color[lastCard.color] < 2 || lastCard.hint.number[lastCard.number] < 2)) {\n    const type = lastCard.hint.number[lastCard.number] < 2 ? \"number\" : \"color\";\n    return {\n      action: \"hint\",\n      from: state.currentPlayer,\n      to: pIndex,\n      type,\n      value: lastCard[type]\n    };\n  } // @todo smarter handling of dangerous cards : give the last card that's dangerous\n  // that's not known to be dangerous\n\n}\n\nexport function chooseAction(state) {\n  // this function finds the most suitable action given the current player's playerView (what they know about the game)\n  // first only implement the case where we play the best card with level 1 deductions\n  // then when it works make the function:\n  // - look behind and make higher level deductions depending on the assumption of optimality of the partners\n  // (assuming those partners use the same lookAhead and lookBehind - 1)\n  // note that those deductions should be kept in memory until challenged, so that the deduction knowledge carries on over rounds\n  // - look ahead to play what triggers the best score\n  // (heuristic = maxPossibleScore + 1.5 * numbers of 5s played + 1 * number of other cards played + 0.5 * happy discards - 1.5 discards - 2 sad discards) ?\n  // assuming those partners use the same lookBehind and lookAhead - 1\n  // if current player has a playable card, play\n  const currentGameView = state.gameViews[state.currentPlayer]; // try to find a definitely playable card\n\n  for (let i = 0; i < currentGameView.hand.length; i++) {\n    const card = currentGameView.hand[i];\n\n    if (card.deductions.every(deduction => isPlayable(deduction, state.playedCards))) {\n      return {\n        action: \"play\",\n        from: state.currentPlayer,\n        cardIndex: i\n      };\n    }\n  }\n\n  if (state.tokens.strikes < 2) {\n    // find the most recent optimist card that may be playable and play it\n    const optimistCardIndex = currentGameView.hand.findIndex(c => c.optimist);\n\n    if (optimistCardIndex > -1 && currentGameView.hand[optimistCardIndex].deductions.some(c => isPlayable(c, state.playedCards))) {\n      return {\n        action: \"play\",\n        from: state.currentPlayer,\n        cardIndex: optimistCardIndex\n      };\n    }\n  }\n\n  if (state.tokens.hints > 0) {\n    // if someone has a playable card (but with some hint uncertainty), give hint\n    for (let i = 1; i < state.options.playersCount; i++) {\n      const pIndex = (state.currentPlayer + i) % state.options.playersCount;\n      const player = Object.values(state.players)[pIndex];\n      const action = findGivableHint(player.hand, pIndex, state);\n\n      if (action) {\n        return action;\n      }\n    }\n  } // discard otherwise\n\n\n  if (state.tokens.hints < 8) {\n    for (let i = currentGameView.hand.length - 1; i >= 0; i--) {\n      const card = currentGameView.hand[i];\n\n      if (isCardDiscardable(card, state)) {\n        return {\n          action: \"discard\",\n          from: state.currentPlayer,\n          cardIndex: i\n        };\n      }\n    }\n  }\n\n  return {\n    action: \"play\",\n    from: state.currentPlayer,\n    cardIndex: 0\n  };\n}\n/**\n * we inspect how the previous person would have played for each possible combination of deductions (i.e possible games)\n * and keep a set of deductions that correspond to what that person actually played.\n */\n\n/**\n * Likewise, looking in the future, we check what the optimal move of the next person would be (in her view)\n * for each of our possible sets of deductions, and play the one that lead to the best outcome after that player\n * has made her action.\n */\n\n/** that recursion is bounded by a max lookahead forwards and backwards. We should check the compute load but it should be alright?\n */\n\nexport default function play(state) {\n  // play an AI action as the current player\n  // @todo this gameview should be persisted from action to action,\n  // we commit\n  const gameView = gameStateToGameView(state);\n  const action = chooseAction(gameView);\n  return commitAction(state, action);\n}","map":{"version":3,"sources":["/Users/sarahmamy/Workspace/hanabi/src/game/ai.ts"],"names":["cloneDeep","filter","findLastIndex","colors","commitAction","getPlayedCardsPile","isPlayable","numbers","IDeductionStatus","isCardPossible","card","possibleCards","findIndex","c","number","color","isCardDangerous","state","isCardEverPlayable","discardPile","find","playedCardsPile","i","discarded","e","cardCount","length","isCardDiscardable","deductions","every","deduction","getHintDeductions","hint","forEach","push","deductionLevel","getPossibleCards","player","drawPile","Object","values","players","hand","map","getLastOptimistCardOfCurrentPlayer","lastTimeHinted","turnsHistory","g","action","to","currentPlayer","lastHintReceived","gameWhenLastHinted","history","firstHintedCard","type","value","gameStateToGameView","gameState","gameViews","lastOptimistCard","gameView","optimist","id","commitViewAction","newState","findGivableHint","pIndex","playedCards","slice","from","lastCard","chooseAction","currentGameView","cardIndex","tokens","strikes","optimistCardIndex","some","hints","options","playersCount","play"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,MAApB,EAA4BC,aAA5B,QAAiD,QAAjD;AAEA,SACEC,MADF,EAEEC,YAFF,EAGEC,kBAHF,EAIEC,UAJF,EAKEC,OALF,QAMO,WANP;AAgBA,WAAYC,gBAAZ;;WAAYA,gB;AAAAA,EAAAA,gB,CAAAA,gB;AAAAA,EAAAA,gB,CAAAA,gB;AAAAA,EAAAA,gB,CAAAA,gB;AAAAA,EAAAA,gB,CAAAA,gB;GAAAA,gB,KAAAA,gB;;AAyBZ;;;AAGA,SAASC,cAAT,CAAwBC,IAAxB,EAAqCC,aAArC,EAAsE;AACpE,SACEA,aAAa,CAACC,SAAd,CACEC,CAAC,IAAIA,CAAC,CAACC,MAAF,KAAaJ,IAAI,CAACI,MAAlB,IAA4BD,CAAC,CAACE,KAAF,KAAYL,IAAI,CAACK,KADpD,IAEI,CAAC,CAHP;AAKD;;AAED,SAASC,eAAT,CAAyBN,IAAzB,EAAsCO,KAAtC,EAAkE;AAChE,MAAI,CAACC,kBAAkB,CAACR,IAAD,EAAOO,KAAP,CAAvB,EAAsC;AACpC,WAAO,KAAP;AACD;;AACD,MAAIP,IAAI,CAACK,KAAL,KAAe,YAAf,IAA+BL,IAAI,CAACI,MAAL,KAAgB,CAAnD,EAAsD;AACpD,WAAO,IAAP;AACD;;AACD,MACEG,KAAK,CAACE,WAAN,CAAkBC,IAAlB,CACEP,CAAC,IAAIA,CAAC,CAACE,KAAF,KAAYL,IAAI,CAACK,KAAjB,IAA0BF,CAAC,CAACC,MAAF,KAAaJ,IAAI,CAACI,MADnD,CADF,EAIE;AACA,WAAO,IAAP;AACD;;AAED,SAAO,KAAP;AACD;;AAED,SAASI,kBAAT,CAA4BR,IAA5B,EAAyCO,KAAzC,EAAqE;AACnE,QAAMI,eAAe,GAAGhB,kBAAkB,CAACY,KAAD,CAA1C,CADmE,CAEnE;;AACA,MAAII,eAAe,CAACX,IAAI,CAACK,KAAN,CAAf,IAA+BL,IAAI,CAACI,MAAxC,EAAgD;AAC9C,WAAO,KAAP;AACD,GAFD,MAEO,IAAIO,eAAe,CAACX,IAAI,CAACK,KAAN,CAAf,GAA8BL,IAAI,CAACI,MAAL,GAAc,CAAhD,EAAmD;AACxD;AACA;AACA,SAAK,IAAIQ,CAAC,GAAGD,eAAe,CAACX,IAAI,CAACK,KAAN,CAAf,GAA8B,CAA3C,EAA8CO,CAAC,GAAGZ,IAAI,CAACI,MAAvD,EAA+DQ,CAAC,EAAhE,EAAoE;AAClE,YAAMC,SAAS,GAAGtB,MAAM,CACtBgB,KAAK,CAACE,WADgB,EAEtBK,CAAC,IAAIA,CAAC,CAACT,KAAF,KAAYL,IAAI,CAACK,KAAjB,IAA0BS,CAAC,CAACV,MAAF,KAAaQ,CAFtB,CAAxB;AAIA,YAAMG,SAAS,GAAGf,IAAI,CAACK,KAAL,KAAe,YAAf,GAA8B,CAA9B,GAAkC,CAApD;;AACA,UAAIQ,SAAS,CAACG,MAAV,KAAqBD,SAAzB,EAAoC;AAClC,eAAO,KAAP;AACD;AACF;AACF;;AAED,SAAO,IAAP;AACD;AAED;;;;;AAGA,SAASE,iBAAT,CAA2BjB,IAA3B,EAA8CO,KAA9C,EAA0E;AACxE;AACA,MACEP,IAAI,CAACkB,UAAL,CAAgBC,KAAhB,CAAsBC,SAAS,IAAI,CAACZ,kBAAkB,CAACY,SAAD,EAAYb,KAAZ,CAAtD,CADF,EAEE;AACA,WAAO,IAAP;AACD,GANuE,CAQxE;;;AACA,MAAIP,IAAI,CAACkB,UAAL,CAAgBC,KAAhB,CAAsBC,SAAS,IAAId,eAAe,CAACc,SAAD,EAAYb,KAAZ,CAAlD,CAAJ,EAA2E;AACzE,WAAO,KAAP;AACD;;AAED,SAAO,IAAP;AACD;;AAED,OAAO,SAASc,iBAAT,CACLC,IADK,EAELrB,aAFK,EAGS;AACd,QAAMiB,UAAwB,GAAG,EAAjC;AACAzB,EAAAA,MAAM,CAAC8B,OAAP,CAAelB,KAAK,IAAI;AACtBR,IAAAA,OAAO,CAAC0B,OAAR,CAAgBnB,MAAM,IAAI;AACxB,UACEkB,IAAI,CAACjB,KAAL,CAAWA,KAAX,IAAoB,CAApB,IACAiB,IAAI,CAAClB,MAAL,CAAYA,MAAZ,IAAsB,CADtB,IAEAL,cAAc,CAAC;AAAEM,QAAAA,KAAF;AAASD,QAAAA;AAAT,OAAD,EAA6BH,aAA7B,CAHhB,EAIE;AACAiB,QAAAA,UAAU,CAACM,IAAX,CAAgB;AACdpB,UAAAA,MAAM,EAAEA,MADM;AAEdC,UAAAA,KAFc;AAGdoB,UAAAA,cAAc,EAAE;AAHF,SAAhB;AAKD;AACF,KAZD;AAaD,GAdD;AAeA,SAAOP,UAAP;AACD;;AAED,SAASQ,gBAAT,CAA0BnB,KAA1B,EAA6CoB,MAA7C,EAAsE;AACpE,SAAO,CAAC,GAAGpB,KAAK,CAACqB,QAAV,EAAoB,GAAGC,MAAM,CAACC,MAAP,CAAcvB,KAAK,CAACwB,OAApB,EAA6BJ,MAA7B,EAAqCK,IAA5D,EAAkEC,GAAlE,CACL9B,CAAC,KAAK;AACJE,IAAAA,KAAK,EAAEF,CAAC,CAACE,KADL;AAEJD,IAAAA,MAAM,EAAED,CAAC,CAACC;AAFN,GAAL,CADI,CAAP;AAMD;AAED;;;;;;;;;;;;;;;;AAoBA,OAAO,SAAS8B,kCAAT,CACL3B,KADK,EAES;AACd,QAAM4B,cAAc,GAAG3C,aAAa,CAClCe,KAAK,CAAC6B,YAD4B,EAElCC,CAAC,IAAIA,CAAC,CAACC,MAAF,CAASA,MAAT,KAAoB,MAApB,IAA8BD,CAAC,CAACC,MAAF,CAASC,EAAT,KAAgBhC,KAAK,CAACiC,aAFvB,CAApC;;AAKA,MAAIL,cAAc,KAAK,CAAC,CAAxB,EAA2B;AACzB,WAAO,IAAP;AACD;;AAED,QAAMM,gBAAgB,GAAGlC,KAAK,CAAC6B,YAAN,CAAmBD,cAAnB,EACtBG,MADH;AAGA,QAAMI,kBAAkB,GACtBnC,KAAK,CAACoC,OAAN,CAAcR,cAAd,EAA8BJ,OAA9B,CAAsCxB,KAAK,CAACiC,aAA5C,EAA2DR,IAD7D;AAGA,QAAMY,eAAe,GAAGF,kBAAkB,CAAChC,IAAnB,CACtBV,IAAI,IAAIA,IAAI,CAACyC,gBAAgB,CAACI,IAAlB,CAAJ,KAAgCJ,gBAAgB,CAACK,KADnC,CAAxB;AAIA,SAAOF,eAAe,IAAI,IAA1B;AACD;AAED,OAAO,SAASG,mBAAT,CAA6BC,SAA7B,EAA+D;AACpE;AACA,QAAMzC,KAAK,GAAGjB,SAAS,CAAC0D,SAAD,CAAvB;AACAzC,EAAAA,KAAK,CAAC0C,SAAN,GAAkB,EAAlB;AAEA,QAAMC,gBAAgB,GAAGhB,kCAAkC,CAAC3B,KAAD,CAA3D,CALoE,CAOpE;AACA;;AACAsB,EAAAA,MAAM,CAACC,MAAP,CAAcvB,KAAK,CAACwB,OAApB,EAA6BR,OAA7B,CAAqC,CAACI,MAAD,EAAkBf,CAAlB,KAAwB;AAC3D,UAAMuC,QAAQ,GAAG;AAAEnB,MAAAA,IAAI,EAAE;AAAR,KAAjB;AACA,UAAM/B,aAAa,GAAGyB,gBAAgB,CAACnB,KAAD,EAAQK,CAAR,CAAtC;AACAe,IAAAA,MAAM,CAACK,IAAP,CAAYT,OAAZ,CAAqBvB,IAAD,IAAiB;AACnCmD,MAAAA,QAAQ,CAACnB,IAAT,CAAcR,IAAd,CAAmB;AACjBF,QAAAA,IAAI,EAAEtB,IAAI,CAACsB,IADM;AAEjBJ,QAAAA,UAAU,EAAEG,iBAAiB,CAACrB,IAAI,CAACsB,IAAN,EAAYrB,aAAZ,CAFZ;AAGjBmD,QAAAA,QAAQ,EAAEF,gBAAgB,IAAIlD,IAAI,CAACqD,EAAL,KAAYH,gBAAgB,CAACG;AAH1C,OAAnB;AAKD,KAND;AAOA9C,IAAAA,KAAK,CAAC0C,SAAN,CAAgBzB,IAAhB,CAAqB2B,QAArB;AACD,GAXD;AAaA,SAAO5C,KAAP;AACD;AAED,OAAO,SAAS+C,gBAAT,CAA0B/C,KAA1B,EAA4C+B,MAA5C,EAAwE;AAC7E;AACA,QAAMiB,QAAQ,GAAG7D,YAAY,CAACa,KAAD,EAAQ+B,MAAR,CAA7B;AACAiB,EAAAA,QAAQ,CAACN,SAAT,GAAqB1C,KAAK,CAAC0C,SAA3B;;AACA,MAAIX,MAAM,CAACA,MAAP,KAAkB,MAAtB,EAA8B,CAC5B;AACD,GAFD,MAEO,CACL;AACD;;AAED,SAAOiB,QAAP;AACD;;AAED,SAASC,eAAT,CACExB,IADF,EAEEyB,MAFF,EAGElD,KAHF,EAIuB;AACrB;AACA;AACA,OAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoB,IAAI,CAAChB,MAAzB,EAAiCJ,CAAC,EAAlC,EAAsC;AACpC,UAAMZ,IAAI,GAAGgC,IAAI,CAACpB,CAAD,CAAjB;;AACA,QACEhB,UAAU,CAACI,IAAD,EAAOO,KAAK,CAACmD,WAAb,CAAV,KACC1D,IAAI,CAACsB,IAAL,CAAUjB,KAAV,CAAgBL,IAAI,CAACK,KAArB,IAA8B,CAA9B,IAAmCL,IAAI,CAACsB,IAAL,CAAUlB,MAAV,CAAiBJ,IAAI,CAACI,MAAtB,IAAgC,CADpE,CADF,EAGE;AACA;AACA;AACA,UAAIyC,IAAJ;;AACA,UAAIb,IAAI,CAAC2B,KAAL,CAAW,CAAX,EAAc/C,CAAd,EAAiBF,IAAjB,CAAsBP,CAAC,IAAIA,CAAC,CAACE,KAAF,KAAYL,IAAI,CAACK,KAA5C,CAAJ,EAAwD;AACtDwC,QAAAA,IAAI,GAAG7C,IAAI,CAACsB,IAAL,CAAUlB,MAAV,CAAiBJ,IAAI,CAACI,MAAtB,IAAgC,CAAhC,GAAoC,QAApC,GAA+C,OAAtD;AACD,OAFD,MAEO;AACLyC,QAAAA,IAAI,GAAG7C,IAAI,CAACsB,IAAL,CAAUjB,KAAV,CAAgBL,IAAI,CAACK,KAArB,IAA8B,CAA9B,GAAkC,OAAlC,GAA4C,QAAnD;AACD;;AACD,aAAO;AACLiC,QAAAA,MAAM,EAAE,MADH;AAELsB,QAAAA,IAAI,EAAErD,KAAK,CAACiC,aAFP;AAGLD,QAAAA,EAAE,EAAEkB,MAHC;AAILZ,QAAAA,IAJK;AAKLC,QAAAA,KAAK,EAAE9C,IAAI,CAAC6C,IAAD;AALN,OAAP;AAOD;AACF,GAzBoB,CA2BrB;;;AACA,QAAMgB,QAAQ,GAAG7B,IAAI,CAACA,IAAI,CAAChB,MAAL,GAAc,CAAf,CAArB;;AACA,MACEV,eAAe,CAACuD,QAAD,EAAWtD,KAAX,CAAf,KACCsD,QAAQ,CAACvC,IAAT,CAAcjB,KAAd,CAAoBwD,QAAQ,CAACxD,KAA7B,IAAsC,CAAtC,IACCwD,QAAQ,CAACvC,IAAT,CAAclB,MAAd,CAAqByD,QAAQ,CAACzD,MAA9B,IAAwC,CAF1C,CADF,EAIE;AACA,UAAMyC,IAAI,GAAGgB,QAAQ,CAACvC,IAAT,CAAclB,MAAd,CAAqByD,QAAQ,CAACzD,MAA9B,IAAwC,CAAxC,GAA4C,QAA5C,GAAuD,OAApE;AACA,WAAO;AACLkC,MAAAA,MAAM,EAAE,MADH;AAELsB,MAAAA,IAAI,EAAErD,KAAK,CAACiC,aAFP;AAGLD,MAAAA,EAAE,EAAEkB,MAHC;AAILZ,MAAAA,IAJK;AAKLC,MAAAA,KAAK,EAAEe,QAAQ,CAAChB,IAAD;AALV,KAAP;AAOD,GA1CoB,CA4CrB;AACA;;AACD;;AAED,OAAO,SAASiB,YAAT,CAAsBvD,KAAtB,EAAiD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,QAAMwD,eAAe,GAAGxD,KAAK,CAAC0C,SAAN,CAAgB1C,KAAK,CAACiC,aAAtB,CAAxB,CAZsD,CAatD;;AACA,OAAK,IAAI5B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmD,eAAe,CAAC/B,IAAhB,CAAqBhB,MAAzC,EAAiDJ,CAAC,EAAlD,EAAsD;AACpD,UAAMZ,IAAI,GAAG+D,eAAe,CAAC/B,IAAhB,CAAqBpB,CAArB,CAAb;;AACA,QACEZ,IAAI,CAACkB,UAAL,CAAgBC,KAAhB,CAAsBC,SAAS,IAC7BxB,UAAU,CAACwB,SAAD,EAAYb,KAAK,CAACmD,WAAlB,CADZ,CADF,EAIE;AACA,aAAO;AACLpB,QAAAA,MAAM,EAAE,MADH;AAELsB,QAAAA,IAAI,EAAErD,KAAK,CAACiC,aAFP;AAGLwB,QAAAA,SAAS,EAAEpD;AAHN,OAAP;AAKD;AACF;;AAED,MAAIL,KAAK,CAAC0D,MAAN,CAAaC,OAAb,GAAuB,CAA3B,EAA8B;AAC5B;AACA,UAAMC,iBAAiB,GAAGJ,eAAe,CAAC/B,IAAhB,CAAqB9B,SAArB,CAA+BC,CAAC,IAAIA,CAAC,CAACiD,QAAtC,CAA1B;;AACA,QACEe,iBAAiB,GAAG,CAAC,CAArB,IACAJ,eAAe,CAAC/B,IAAhB,CAAqBmC,iBAArB,EAAwCjD,UAAxC,CAAmDkD,IAAnD,CAAwDjE,CAAC,IACvDP,UAAU,CAACO,CAAD,EAAII,KAAK,CAACmD,WAAV,CADZ,CAFF,EAKE;AACA,aAAO;AACLpB,QAAAA,MAAM,EAAE,MADH;AAELsB,QAAAA,IAAI,EAAErD,KAAK,CAACiC,aAFP;AAGLwB,QAAAA,SAAS,EAAEG;AAHN,OAAP;AAKD;AACF;;AAED,MAAI5D,KAAK,CAAC0D,MAAN,CAAaI,KAAb,GAAqB,CAAzB,EAA4B;AAC1B;AACA,SAAK,IAAIzD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,KAAK,CAAC+D,OAAN,CAAcC,YAAlC,EAAgD3D,CAAC,EAAjD,EAAqD;AACnD,YAAM6C,MAAM,GAAG,CAAClD,KAAK,CAACiC,aAAN,GAAsB5B,CAAvB,IAA4BL,KAAK,CAAC+D,OAAN,CAAcC,YAAzD;AACA,YAAM5C,MAAM,GAAGE,MAAM,CAACC,MAAP,CAAcvB,KAAK,CAACwB,OAApB,EAA6B0B,MAA7B,CAAf;AAEA,YAAMnB,MAAM,GAAGkB,eAAe,CAAC7B,MAAM,CAACK,IAAR,EAAcyB,MAAd,EAAsBlD,KAAtB,CAA9B;;AACA,UAAI+B,MAAJ,EAAY;AACV,eAAOA,MAAP;AACD;AACF;AACF,GAzDqD,CA2DtD;;;AACA,MAAI/B,KAAK,CAAC0D,MAAN,CAAaI,KAAb,GAAqB,CAAzB,EAA4B;AAC1B,SAAK,IAAIzD,CAAC,GAAGmD,eAAe,CAAC/B,IAAhB,CAAqBhB,MAArB,GAA8B,CAA3C,EAA8CJ,CAAC,IAAI,CAAnD,EAAsDA,CAAC,EAAvD,EAA2D;AACzD,YAAMZ,IAAI,GAAG+D,eAAe,CAAC/B,IAAhB,CAAqBpB,CAArB,CAAb;;AACA,UAAIK,iBAAiB,CAACjB,IAAD,EAAOO,KAAP,CAArB,EAAoC;AAClC,eAAO;AACL+B,UAAAA,MAAM,EAAE,SADH;AAELsB,UAAAA,IAAI,EAAErD,KAAK,CAACiC,aAFP;AAGLwB,UAAAA,SAAS,EAAEpD;AAHN,SAAP;AAKD;AACF;AACF;;AAED,SAAO;AACL0B,IAAAA,MAAM,EAAE,MADH;AAELsB,IAAAA,IAAI,EAAErD,KAAK,CAACiC,aAFP;AAGLwB,IAAAA,SAAS,EAAE;AAHN,GAAP;AAKD;AAED;;;;;AAKA;;;;;;AAMA;;;AAGA,eAAe,SAASQ,IAAT,CAAcjE,KAAd,EAA6C;AAC1D;AACA;AACA;AACA,QAAM4C,QAAQ,GAAGJ,mBAAmB,CAACxC,KAAD,CAApC;AACA,QAAM+B,MAAM,GAAGwB,YAAY,CAACX,QAAD,CAA3B;AACA,SAAOzD,YAAY,CAACa,KAAD,EAAQ+B,MAAR,CAAnB;AACD","sourcesContent":["import { cloneDeep, filter, findLastIndex } from \"lodash\";\n\nimport {\n  colors,\n  commitAction,\n  getPlayedCardsPile,\n  isPlayable,\n  numbers\n} from \"./actions\";\nimport IGameState, {\n  IAction,\n  ICard,\n  ICardHint,\n  IHintAction,\n  INumber,\n  IPlayer\n} from \"./state\";\n\nexport enum IDeductionStatus {\n  PLAYABLE = 0, // the card value is such that it can be played right now\n  HAPPYDISCARD, // the card can never be useful, free money\n  DISCARD, // the card can be discarded, there's another one like this in the draw pile\n  SADDISCARD // if discarded, the card leads to a lost point (incomplete pile)\n}\n\nexport interface IPlayerView {\n  hand: IHiddenCard[];\n}\n\n/**\n * A hidden card has an array of deductions, i.e. possible values with deduction levels\n *\n * A hidden card is said to be \"optimist\" when it's (one of) the last card(s) that was designated for a hint\n * since the player last played.\n * When there are several possible deductions for a card, we always assume that playing it/ discarding it\n * leads to the worst possible outcome, unless it's an optimist card in which case we trust our partners :)\n */\nexport interface IHiddenCard {\n  hint: ICardHint;\n  deductions: IDeduction[];\n  optimist: boolean;\n}\n\n/**\n * Check whether the current card can be in hand\n */\nfunction isCardPossible(card: ICard, possibleCards: ICard[]): boolean {\n  return (\n    possibleCards.findIndex(\n      c => c.number === card.number && c.color === card.color\n    ) > -1\n  );\n}\n\nfunction isCardDangerous(card: ICard, state: IGameState): boolean {\n  if (!isCardEverPlayable(card, state)) {\n    return false;\n  }\n  if (card.color === \"multicolor\" || card.number === 5) {\n    return true;\n  }\n  if (\n    state.discardPile.find(\n      c => c.color === card.color && c.number === card.number\n    )\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isCardEverPlayable(card: ICard, state: IGameState): boolean {\n  const playedCardsPile = getPlayedCardsPile(state);\n  // if the card has already been played once\n  if (playedCardsPile[card.color] >= card.number) {\n    return false;\n  } else if (playedCardsPile[card.color] < card.number - 1) {\n    // let's check whether the cards in between have been discarded\n    // e.g. the game pile is a 3 Red, the 2 4s in the discard, and I have a 5 Red\n    for (let i = playedCardsPile[card.color] + 1; i < card.number; i++) {\n      const discarded = filter(\n        state.discardPile,\n        e => e.color === card.color && e.number === i\n      );\n      const cardCount = card.color === \"multicolor\" ? 1 : 2;\n      if (discarded.length === cardCount) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Check whether the current card can be discarded\n */\nfunction isCardDiscardable(card: IHiddenCard, state: IGameState): boolean {\n  // AI can discard a card that can never be played (already played or because of discards)\n  if (\n    card.deductions.every(deduction => !isCardEverPlayable(deduction, state))\n  ) {\n    return true;\n  }\n\n  // don't discard necessarily dangerous cards\n  if (card.deductions.every(deduction => isCardDangerous(deduction, state))) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function getHintDeductions(\n  hint: ICardHint,\n  possibleCards: ICard[]\n): IDeduction[] {\n  const deductions: IDeduction[] = [];\n  colors.forEach(color => {\n    numbers.forEach(number => {\n      if (\n        hint.color[color] > 0 &&\n        hint.number[number] > 0 &&\n        isCardPossible({ color, number } as ICard, possibleCards)\n      ) {\n        deductions.push({\n          number: number as INumber,\n          color,\n          deductionLevel: 0\n        } as IDeduction);\n      }\n    });\n  });\n  return deductions;\n}\n\nfunction getPossibleCards(state: IGameState, player: number): ICard[] {\n  return [...state.drawPile, ...Object.values(state.players)[player].hand].map(\n    c => ({\n      color: c.color,\n      number: c.number\n    })\n  );\n}\n\n/**\n * A deduction is a possible value for a card, inferred from different deduction levels.\n * Level 0: all possible values (color, number) given the card's hints are of level 0 (or more)\n * Level 1: all possible values given the card's hints and all observable cards (other players games, discard pile) are of level 1 (or more)\n * Level 2: all level 1 values that are compatible with the previous player's action being optimal\n * Level 3: all level 2 values that are compatible with the the two previous actions being optimal\n * ...\n * A higher level deduction is less certain (although 0 and 1 are certain and deterministic)\n * but makes the card more likely to be played.\n *\n * Before playing, each deduction will be assigned a status (IDeductionStatus)\n * (playing a 5) > (playing a playable card) > (happy discard) > (giving a hint) > (discard) > (sad discard)\n *\n */\nexport interface IDeduction extends ICard {\n  deductionLevel: number;\n}\n\nexport type IGameView = IGameState & { gameViews: IPlayerView[] };\n\nexport function getLastOptimistCardOfCurrentPlayer(\n  state: IGameState\n): ICard | null {\n  const lastTimeHinted = findLastIndex(\n    state.turnsHistory,\n    g => g.action.action === \"hint\" && g.action.to === state.currentPlayer\n  );\n\n  if (lastTimeHinted === -1) {\n    return null;\n  }\n\n  const lastHintReceived = state.turnsHistory[lastTimeHinted]\n    .action as IHintAction;\n\n  const gameWhenLastHinted =\n    state.history[lastTimeHinted].players[state.currentPlayer].hand;\n\n  const firstHintedCard = gameWhenLastHinted.find(\n    card => card[lastHintReceived.type] === lastHintReceived.value\n  );\n\n  return firstHintedCard || null;\n}\n\nexport function gameStateToGameView(gameState: IGameState): IGameView {\n  // copy the state\n  const state = cloneDeep(gameState) as IGameView;\n  state.gameViews = [];\n\n  const lastOptimistCard = getLastOptimistCardOfCurrentPlayer(state);\n\n  // add a parallel array to the players that give their view of the game\n  // and make all level 0 deductions\n  Object.values(state.players).forEach((player: IPlayer, i) => {\n    const gameView = { hand: [] };\n    const possibleCards = getPossibleCards(state, i);\n    player.hand.forEach((card: ICard) => {\n      gameView.hand.push({\n        hint: card.hint,\n        deductions: getHintDeductions(card.hint, possibleCards),\n        optimist: lastOptimistCard && card.id === lastOptimistCard.id\n      } as IHiddenCard);\n    });\n    state.gameViews.push(gameView);\n  });\n\n  return state;\n}\n\nexport function commitViewAction(state: IGameView, action: IAction): IGameView {\n  // change how players change their views given a certain action\n  const newState = commitAction(state, action) as IGameView;\n  newState.gameViews = state.gameViews;\n  if (action.action === \"hint\") {\n    // @todo change the player view of the person who received a hint\n  } else {\n    // @todo check what card was just drawn and apply new knowledge to other players\n  }\n\n  return newState;\n}\n\nfunction findGivableHint(\n  hand: ICard[],\n  pIndex: number,\n  state: IGameState\n): IAction | undefined {\n  // find the first playable card and give a hint on it.\n  // if possible, give an optimist hint.\n  for (let i = 0; i < hand.length; i++) {\n    const card = hand[i];\n    if (\n      isPlayable(card, state.playedCards) &&\n      (card.hint.color[card.color] < 2 || card.hint.number[card.number] < 2)\n    ) {\n      // find the type of hint to give, trying to find the most optimist one\n      // (if there's a card with the same color, give the number hint)\n      let type;\n      if (hand.slice(0, i).find(c => c.color === card.color)) {\n        type = card.hint.number[card.number] < 2 ? \"number\" : \"color\";\n      } else {\n        type = card.hint.color[card.color] < 2 ? \"color\" : \"number\";\n      }\n      return {\n        action: \"hint\",\n        from: state.currentPlayer,\n        to: pIndex,\n        type,\n        value: card[type]\n      };\n    }\n  }\n\n  // give a hint on the last card to avoid discard if possible\n  const lastCard = hand[hand.length - 1];\n  if (\n    isCardDangerous(lastCard, state) &&\n    (lastCard.hint.color[lastCard.color] < 2 ||\n      lastCard.hint.number[lastCard.number] < 2)\n  ) {\n    const type = lastCard.hint.number[lastCard.number] < 2 ? \"number\" : \"color\";\n    return {\n      action: \"hint\",\n      from: state.currentPlayer,\n      to: pIndex,\n      type,\n      value: lastCard[type]\n    };\n  }\n\n  // @todo smarter handling of dangerous cards : give the last card that's dangerous\n  // that's not known to be dangerous\n}\n\nexport function chooseAction(state: IGameView): IAction {\n  // this function finds the most suitable action given the current player's playerView (what they know about the game)\n  // first only implement the case where we play the best card with level 1 deductions\n  // then when it works make the function:\n  // - look behind and make higher level deductions depending on the assumption of optimality of the partners\n  // (assuming those partners use the same lookAhead and lookBehind - 1)\n  // note that those deductions should be kept in memory until challenged, so that the deduction knowledge carries on over rounds\n  // - look ahead to play what triggers the best score\n  // (heuristic = maxPossibleScore + 1.5 * numbers of 5s played + 1 * number of other cards played + 0.5 * happy discards - 1.5 discards - 2 sad discards) ?\n  // assuming those partners use the same lookBehind and lookAhead - 1\n\n  // if current player has a playable card, play\n  const currentGameView = state.gameViews[state.currentPlayer];\n  // try to find a definitely playable card\n  for (let i = 0; i < currentGameView.hand.length; i++) {\n    const card = currentGameView.hand[i];\n    if (\n      card.deductions.every(deduction =>\n        isPlayable(deduction, state.playedCards)\n      )\n    ) {\n      return {\n        action: \"play\",\n        from: state.currentPlayer,\n        cardIndex: i\n      };\n    }\n  }\n\n  if (state.tokens.strikes < 2) {\n    // find the most recent optimist card that may be playable and play it\n    const optimistCardIndex = currentGameView.hand.findIndex(c => c.optimist);\n    if (\n      optimistCardIndex > -1 &&\n      currentGameView.hand[optimistCardIndex].deductions.some(c =>\n        isPlayable(c, state.playedCards)\n      )\n    ) {\n      return {\n        action: \"play\",\n        from: state.currentPlayer,\n        cardIndex: optimistCardIndex\n      };\n    }\n  }\n\n  if (state.tokens.hints > 0) {\n    // if someone has a playable card (but with some hint uncertainty), give hint\n    for (let i = 1; i < state.options.playersCount; i++) {\n      const pIndex = (state.currentPlayer + i) % state.options.playersCount;\n      const player = Object.values(state.players)[pIndex];\n\n      const action = findGivableHint(player.hand, pIndex, state);\n      if (action) {\n        return action;\n      }\n    }\n  }\n\n  // discard otherwise\n  if (state.tokens.hints < 8) {\n    for (let i = currentGameView.hand.length - 1; i >= 0; i--) {\n      const card = currentGameView.hand[i];\n      if (isCardDiscardable(card, state)) {\n        return {\n          action: \"discard\",\n          from: state.currentPlayer,\n          cardIndex: i\n        };\n      }\n    }\n  }\n\n  return {\n    action: \"play\",\n    from: state.currentPlayer,\n    cardIndex: 0\n  };\n}\n\n/**\n * we inspect how the previous person would have played for each possible combination of deductions (i.e possible games)\n * and keep a set of deductions that correspond to what that person actually played.\n */\n\n/**\n * Likewise, looking in the future, we check what the optimal move of the next person would be (in her view)\n * for each of our possible sets of deductions, and play the one that lead to the best outcome after that player\n * has made her action.\n */\n\n/** that recursion is bounded by a max lookahead forwards and backwards. We should check the compute load but it should be alright?\n */\n\nexport default function play(state: IGameState): IGameState {\n  // play an AI action as the current player\n  // @todo this gameview should be persisted from action to action,\n  // we commit\n  const gameView = gameStateToGameView(state);\n  const action = chooseAction(gameView);\n  return commitAction(state, action);\n}\n"]},"metadata":{},"sourceType":"module"}